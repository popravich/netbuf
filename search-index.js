var searchIndex = {};
searchIndex["netbuf"] = {"doc":"This module currently includes single `Buf` struct for holding buffers.\nComparing to `Vec` class buffer has different allocation policy and has\na marker of consumed data (i.e. already processed by protocol parser or\nalready written to socket)","items":[[3,"Buf","netbuf","",null,null],[4,"RangeArgument","","Temporary type until the one in stdlib it made stable",null,null],[13,"RangeFrom","","",0,null],[13,"Range","","",0,null],[13,"RangeTo","","",0,null],[11,"new","","Create empty buffer. It has no preallocated size. It&#39;s always have\ndeallocated underlying memory chunk when there are no useful bytes\nin the buffer.",1,{"inputs":[],"output":{"name":"buf"}}],[11,"consume","","Mark the first `bytes` of the buffer as read. Basically it&#39;s shaving\noff bytes from the buffer. But does it effeciently. When there are\nno more bytes in the buffer it&#39;s deallocated.",1,{"inputs":[{"name":"buf"},{"name":"usize"}],"output":null}],[11,"remove_range","","Allows to remove arbitrary range of bytes",1,{"inputs":[{"name":"buf"},{"name":"r"}],"output":null}],[11,"capacity","","Capacity of the buffer. I.e. the bytes it is allocated for. Use for\ndebugging or for calculating memory usage. Note it&#39;s not guaranteed\nthat you can write `buf.capacity() - buf.len()` bytes without resize",1,{"inputs":[{"name":"buf"}],"output":{"name":"usize"}}],[11,"len","","Number of useful bytes in the buffer",1,{"inputs":[{"name":"buf"}],"output":{"name":"usize"}}],[11,"is_empty","","Is buffer is empty. Potentially a little bit faster than\ngetting `len()`",1,{"inputs":[{"name":"buf"}],"output":{"name":"bool"}}],[11,"extend","","Extend buffer. Note unlike `Write::write()` and `read_from()` this\nmethod reserves smallest possible chunk of memory. So it&#39;s inefficient\nto grow with this method.  You may use Write trait to grow\nincrementally.",1,null],[11,"read_from","","Read some bytes from stream (object implementing `Read`) into buffer",1,{"inputs":[{"name":"buf"},{"name":"r"}],"output":{"name":"result"}}],[11,"read_max_from","","Reads no more than max bytes into buffer and returns boolean flag\nof whether max bytes are reached",1,{"inputs":[{"name":"buf"},{"name":"usize"},{"name":"r"}],"output":{"name":"result"}}],[11,"write_to","","Write contents of buffer to the stream (object implementing\nthe Write trait). We assume that stream is non-blocking, use\n`Write::write` (instead of `Write::write_all`) and return all errors\nto the caller (including `WouldBlock` or `Interrupted`).",1,{"inputs":[{"name":"buf"},{"name":"w"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"buf"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"into","","",1,{"inputs":[{"name":"buf"}],"output":{"name":"vec"}}],[11,"index","","",1,{"inputs":[{"name":"buf"},{"name":"usize"}],"output":{"name":"u8"}}],[11,"index","","",1,null],[11,"index","","",1,null],[11,"index","","",1,null],[11,"index","","",1,null],[11,"index_mut","","",1,{"inputs":[{"name":"buf"},{"name":"usize"}],"output":{"name":"u8"}}],[11,"index_mut","","",1,null],[11,"index_mut","","",1,null],[11,"index_mut","","",1,null],[11,"index_mut","","",1,null],[11,"write","","",1,null],[11,"flush","","",1,{"inputs":[{"name":"buf"}],"output":{"name":"result"}}],[11,"from","","",0,{"inputs":[{"name":"range"}],"output":{"name":"rangeargument"}}],[11,"from","","",0,{"inputs":[{"name":"rangefrom"}],"output":{"name":"rangeargument"}}],[11,"from","","",0,{"inputs":[{"name":"rangeto"}],"output":{"name":"rangeargument"}}],[11,"from","","",0,{"inputs":[{"name":"rangefull"}],"output":{"name":"rangeargument"}}],[17,"MAX_BUF_SIZE","","Maximum size of buffer allowed.\nNote: we assert on this size. Most network servers should set their own\nlimits to something much smaller.",null,null]],"paths":[[4,"RangeArgument"],[3,"Buf"]]};
initSearch(searchIndex);
